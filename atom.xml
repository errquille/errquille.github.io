<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Studentský blog</title>
  
  <subtitle>Nevěřte všemu, co najdete na internetu.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://errquille.github.io/"/>
  <updated>2017-04-25T09:44:03.907Z</updated>
  <id>http://errquille.github.io/</id>
  
  <author>
    <name>Šimon Wernisch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Metodika pro analýzu síťového zpoždění</title>
    <link href="http://errquille.github.io/2017/04/25/metodika-pro-analyzu-sitoveho-zpozdeni/"/>
    <id>http://errquille.github.io/2017/04/25/metodika-pro-analyzu-sitoveho-zpozdeni/</id>
    <published>2017-04-25T09:03:02.000Z</published>
    <updated>2017-04-25T09:44:03.907Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --><p>V posledních dvou týdnech jsem dokončoval nástroje pro měření zpoždění a ztrátovosti paketů v Java aplikaci našich autíček. K dokončení této části mé práce tedy zbývá změřit a analyzovat především to zpoždění. Ztrátovost proti zpoždění, které lze s menší chybou určit na základě časových značek vždy, nelze u UDP měřit přímo, což z ní dělá méně zajímavou informaci. U TCP vychází ztrátovost přímo z míry opětovných vysílání (retransmission), jenže my používáme UDP. Přesto ztrátovost budu měřit, a to v rámci procesu periodického vysílání, kde se očekává vzorek v každé periodě.</p><h1 id="Metodika-analyzy"><a href="#Metodika-analyzy" class="headerlink" title="Metodika analýzy"></a>Metodika analýzy</h1><ol><li><p>Určit bandwidth</p><p>Tato informace je statická pro použitý hardware.</p></li><li><p>Určit využití kanálů v oblasti pracoviště</p><p>To by mělo být spíše obrazné, v oblasti budov školy na Karlově náměstí se nacházejí desítky SSID ve všech běžně využívaných pásmech. Bohužel nad nimi nemám žádnou kontrolu, akorát mohu zkusit odhadnout, jak bude probíhat TDMA.</p></li><li><p>Změřit zpoždění</p><p>Měření zpoždění má své vlastní náležitosti. Měření vychází z časových značek, které zaznamenáváme při událostech, jako je vytvoření paketu a přijetí paketu k zpracování. Poté přes delší časový úsek určíme statistické metriky jako střední hodnota, rozptyl, některé kvantily (napříkad první decil) a také grafiku, časový průběh a histogram, nejlépe v logaritmickém měřítku.</p></li><li><p>Prozkoumat vliv velikosti paketu a využití bandwidth</p><p>Oba parametry mají poměrně velký vliv na velikost a rozložení zpoždění. Rozsahy jsou 64 - 1500 bajtů pro velikost a 0 - 100 % pro využití. Stálo by za to změřit krajní případy a některé další a případně najít korelaci.</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --&gt;&lt;p&gt;V posledních dvou týdnech jsem dokončoval nástroje pro měření zpoždění a
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Čistá instalace pro RPi</title>
    <link href="http://errquille.github.io/2017/03/29/cista-instalace-pro-rpi/"/>
    <id>http://errquille.github.io/2017/03/29/cista-instalace-pro-rpi/</id>
    <published>2017-03-29T13:33:18.000Z</published>
    <updated>2017-04-06T18:40:47.115Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --><h2 id="Situace"><a href="#Situace" class="headerlink" title="Situace"></a>Situace</h2><p>Po řadě úprav a testování jsem se dostal do bodu, kde chci svůj upravený systém přenést z jednoho testovacího autíčka do všech, máme jich kolem pěti. Postup je</p><ol><li>Udělat kopii celého souborového systému</li><li>Kopií přepsat souborový systém ostatních</li><li>Udělat individuální změny</li></ol><p>Na autíčku je však spousta testovacího bordelu a možná i pozůstatky některých odvolaných změn. Rád si tedy vytvořím čistý obraz Raspbianu se všemi změnami.</p><h2 id="Cerstvy-system"><a href="#Cerstvy-system" class="headerlink" title="Čerstvý systém"></a>Čerstvý systém</h2><h3 id="Prvni-krok"><a href="#Prvni-krok" class="headerlink" title="První krok"></a>První krok</h3><p>Nástroj, který poslouží k vytvoření základu raspbianu, je debootstrap. Pracuji v počítači, na kterém běží Archlinux na x86_64 procesoru. To dělá překážku, protože chci vybudovat systém pro ARM. Pro začátek aspoň necháme proběhnout první část debootstrap skriptu, která neselže.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ debootstrap --arch=armhf --foreign --no-check-gpg jessie ./jessie-armhf-rpi http://archive.raspbian.org/raspbian</div></pre></td></tr></table></figure><p></p><h3 id="Dynamicka-interpretace-binarnich-souboru"><a href="#Dynamicka-interpretace-binarnich-souboru" class="headerlink" title="Dynamická interpretace binárních souborů"></a>Dynamická interpretace binárních souborů</h3><p>Vyřešit se to dá díky <a href="https://aur.archlinux.org/packages/qemu-user-static/" target="_blank" rel="external">qemu-arm-static</a> a <a href="https://aur.archlinux.org/packages/binfmt-support/" target="_blank" rel="external">binfmt-support</a>. Po instalaci těchto dvou je třeba zkopírovat qemu-arm-static do raspbianu a zaregistrovat qemu-arm s binfmt-support.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cp /bin/qemu-arm-static jessie-armhf-rpi/usr/bin/</div><div class="line">$ update-binfmts --enable qemu-arm</div></pre></td></tr></table></figure><p></p><p>Nyní se binární soubory raspbianu spustí i na x86-64 systému.</p><h3 id="Druhy-krok"><a href="#Druhy-krok" class="headerlink" title="Druhý krok"></a>Druhý krok</h3><p>Teď k dokončení debootstrapu.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chroot jessie-armhf-rpi /debootstrap/debootstrap --second-stage</div></pre></td></tr></table></figure><p></p><h2 id="Pridani-vlastniho-kernelu-a-firmware"><a href="#Pridani-vlastniho-kernelu-a-firmware" class="headerlink" title="Přidání vlastního kernelu a firmware"></a>Přidání vlastního kernelu a firmware</h2><h3 id="Vlastni-kernel"><a href="#Vlastni-kernel" class="headerlink" title="Vlastní kernel"></a>Vlastní kernel</h3><p>První změny budou stejné, jak jsem je popsal v <a href="/2017/03/13/Zprovozneni-linuxptp-na-Raspberry-Pi/" title="článku o zprovoznění linuxptp">článku o zprovoznění linuxptp</a>. Po kompilaci<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cp arch/arm/boot/zImage ../raspbian/jessie-armhf-rpi/boot/kernel.img</div><div class="line">$ cp arch/arm/boot/dts/*.dtb ../raspbian/jessie-armhf-rpi/boot</div><div class="line">$ cp arch/arm/boot/dts/overlays/*.dtb* ../raspbian/jessie-armhf-rpi/boot/overlays/</div><div class="line">$ make -C ~/workspace/slotcar-kernel ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CCPREFIX&#125;</span> -j5 INSTALL_MOD_PATH=../raspbian/jessie-armhf-rpi modules_install</div><div class="line">$ make -C ~/workspace/slotcar-kernel ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CCPREFIX&#125;</span> -j5 INSTALL_HDR_PATH=../raspbian/jessie-armhf-rpi/usr/src headers_install</div></pre></td></tr></table></figure><p></p><h3 id="Firmware"><a href="#Firmware" class="headerlink" title="Firmware"></a>Firmware</h3><p>Firmware pro Raspberry je vhodné aktualizovat a udržovat spolu s kernelem. Pull z githubu pro firmware tedy provést spolu s kernelem.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://github.com/raspberrypi/firmware.git</div></pre></td></tr></table></figure><p></p><p>Z toho zkopírujeme soubory bootcode.bin, fixup.dat a start.elf do boot složky. Pak ještě VC knihovny s hard float operacemi.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cp firmware/boot/bootcode.bin jessie-armhf-rpi/boot</div><div class="line">$ cp firmware/boot/fixup.dat jessie-armhf-rpi/boot</div><div class="line">$ cp firmware/boot/start.elf jessie-armhf-rpi/boot</div><div class="line">$ cp firmware/hardfp/opt/vc jessie-armhf-rpi/opt</div></pre></td></tr></table></figure><h2 id="Prace-v-systemu"><a href="#Prace-v-systemu" class="headerlink" title="Práce v systému"></a>Práce v systému</h2><p>Chroot je dobrý nástroj, ale já bych v systému rád provedl i změny v init systému systemd. Ten není chrootem zaveden. Místo chroot tedy systemd-nspawn. Ten spustí raspbian v linux kontajneru.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemd-nspawn -b -D jessie-armhf-rpi</div></pre></td></tr></table></figure><p></p><h3 id="Pocatecni-nastaveni-uzivatelu"><a href="#Pocatecni-nastaveni-uzivatelu" class="headerlink" title="Počáteční nastavení uživatelů"></a>Počáteční nastavení uživatelů</h3><p>Nyní už uvnitř nového systému<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"slotcar"</span> &gt; /etc/hostname</div><div class="line">$ passwd</div><div class="line"></div><div class="line">$ adduser pi</div><div class="line">$ usermod <span class="_">-a</span> -G sudo,staff,kmem,plugdev pi</div></pre></td></tr></table></figure><p></p><h3 id="Apt-get"><a href="#Apt-get" class="headerlink" title="Apt-get"></a>Apt-get</h3><p>Upgrade balíčků provedeme klasicky, ale nejdříve upravíme seznam zdrojů apt<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ cat &gt; /etc/apt/sources.list &lt;&lt; EOF</div><div class="line">deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi</div><div class="line">deb http://archive.raspberrypi.org/debian/ jessie main</div><div class="line">EOF</div><div class="line"></div><div class="line">$ wget http://archive.raspbian.org/raspbian.public.key -O - | apt-key add -</div><div class="line">$ wget http://archive.raspberrypi.org/debian/raspberrypi.gpg.key -O - | apt-key add -</div><div class="line">$ apt-get update</div><div class="line">$ apt-get dist-upgrade</div><div class="line">$ apt-get clean</div></pre></td></tr></table></figure><p></p><p>Následující příkaz nám poví, které balíčky zabírají nejvíce místa<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ dpkg-query -W --showformat=<span class="string">'$&#123;Installed-Size;10&#125;\t$&#123;Package&#125;\n'</span> | sort -k1,1n | tail -n 20</div><div class="line">      2181tar</div><div class="line">      2251libssl1.0.0</div><div class="line">      2266libxapian22</div><div class="line">      2442util-linux</div><div class="line">      2511libapt-pkg4.12</div><div class="line">      2667groff-base</div><div class="line">      2687e2fsprogs</div><div class="line">      2917libc-bin</div><div class="line">      3020apt</div><div class="line">      3839aptitude</div><div class="line">      4332perl-base</div><div class="line">      4701gnupg</div><div class="line">      4836bash</div><div class="line">      5806udev</div><div class="line">      6435dpkg</div><div class="line">      8811libc6</div><div class="line">      9930aptitude-common</div><div class="line">     10445systemd</div><div class="line">     12955coreutils</div><div class="line">     26535libicu52</div></pre></td></tr></table></figure><p></p><p>Systém je velice čistý, určitě si časem uvědomíme, že nám tam něco chybí, a přidáme. Co tam momentálně přidáme je<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openjdk-8-jre ssh-server</div></pre></td></tr></table></figure><p></p><h3 id="Slotcar-fs"><a href="#Slotcar-fs" class="headerlink" title="Slotcar-fs"></a>Slotcar-fs</h3><h3 id="Tvorba-obrazu-souboroveho-systemu"><a href="#Tvorba-obrazu-souboroveho-systemu" class="headerlink" title="Tvorba obrazu souborového systému"></a>Tvorba obrazu souborového systému</h3><h2 id="Naklonovani-do-auticka"><a href="#Naklonovani-do-auticka" class="headerlink" title="Naklonování do autíčka"></a>Naklonování do autíčka</h2><p>Poslední krok je naklonovat obraz do testovacího autíčka a udělat lokální úpravy.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dd <span class="keyword">if</span>=raspbian-slotcar.img of=/dev/sdb1 status=progress</div></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --&gt;&lt;h2 id=&quot;Situace&quot;&gt;&lt;a href=&quot;#Situace&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Generátor PPS signálu na GPIO</title>
    <link href="http://errquille.github.io/2017/03/23/generator-pps-signalu-na-gpio/"/>
    <id>http://errquille.github.io/2017/03/23/generator-pps-signalu-na-gpio/</id>
    <published>2017-03-23T21:04:16.000Z</published>
    <updated>2017-03-23T22:00:55.109Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --><h2 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h2><p>Je to eletrický signál, který má hranu přesně s tiknutím sekundy. Ten může sloužit k propojení přesných zdrojů hodin s jinými zařízeními, ale v mém případě poslouží k porovnání dvou hodin na oscilátoru.</p><h2 id="Generator-PPS-signalu"><a href="#Generator-PPS-signalu" class="headerlink" title="Generátor PPS signálu"></a>Generátor PPS signálu</h2><p>V linuxu je podpora pouze pro generování na paralelní port, GPIO zde není. Na githubu je k nalezení projekt <a href="https://github.com/jsln/pps-gen-gpio" target="_blank" rel="external">https://github.com/jsln/pps-gen-gpio</a>, který tento generátor upravuje na GPIO pro Beaglebone Black. Zdrojový kód tedy přidáme k zdrojovému kódu kernelu do složky drivers/pps/generators. Aby byl na GPIO Raspberry vygenerován signál, je však ještě zapotřebí upravit <a href="https://www.raspberrypi.org/documentation/configuration/device-tree.md" target="_blank" rel="external">device tree</a>. Vytvoříme nový DT overlay.</p><figure class="highlight dts"><figcaption><span>arch/arm/boot/dts/overlays/pps-gen-gpio-overlay.dts</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta-keyword">/dts-v1/</span>;</div><div class="line"><span class="meta-keyword">/plugin/</span>;</div><div class="line"></div><div class="line"><span class="class">/ &#123;</span></div><div class="line">compatible = <span class="string">"brcm,bcm2708"</span>;</div><div class="line"><span class="class">fragment@0 </span>&#123;</div><div class="line">target-path = <span class="string">"/"</span>;</div><div class="line"><span class="class">__overlay__ </span>&#123;</div><div class="line"><span class="symbol">pps_gen:</span> <span class="class">pps_gen </span>&#123;</div><div class="line">pinctrl-names = <span class="string">"default"</span>;</div><div class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pps_gen_pins</span>&gt;</span>;</div><div class="line">compatible = <span class="string">"pps-gen-gpios"</span>;</div><div class="line">pps-gen-gpios = <span class="params">&lt;<span class="variable">&amp;gpio</span> <span class="number">25</span> <span class="number">0</span>&gt;</span>;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class">fragment@1 </span>&#123;</div><div class="line">target = <span class="params">&lt;<span class="variable">&amp;gpio</span>&gt;</span>;</div><div class="line"><span class="class">__overlay__ </span>&#123;</div><div class="line"><span class="symbol">pps_gen_pins:</span> <span class="class">pps_gen_pins </span>&#123;</div><div class="line">brcm,pins =     <span class="params">&lt;<span class="number">25</span>&gt;</span>;</div><div class="line">brcm,function = <span class="params">&lt;<span class="number">1</span>&gt;</span>;    <span class="comment">// out</span></div><div class="line">brcm,pull =     <span class="params">&lt;<span class="number">0</span>&gt;</span>;    <span class="comment">// none</span></div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class">__overrides__ </span>&#123;</div><div class="line">gpiopin = <span class="params">&lt;<span class="variable">&amp;pps_gen</span>&gt;</span>,<span class="string">"gpios:4"</span>,</div><div class="line">  <span class="params">&lt;<span class="variable">&amp;pps_gen_pins</span>&gt;</span>,<span class="string">"brcm,pins:0"</span>;</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Nyní je vše připraveno a po zkompilování a nahrání do Raspberry se modul generátoru spustí načtením tohoto overlay. To lze provést buď při každém zapnutí zařízení úpravou souboru /boot/config.txt nebo dynamicky zavoláním příkazu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dtoverlay pps-gen-gpio</div></pre></td></tr></table></figure><p>V tomto případě lze pin uvolnit přidáním přepínače -r a nebo změnit pin přidáním gpiopin=#pinu.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --&gt;&lt;h2 id=&quot;PPS&quot;&gt;&lt;a href=&quot;#PPS&quot; class=&quot;headerlink&quot; title=&quot;PPS&quot;&gt;&lt;/a&gt;PPS&lt;/h2&gt;&lt;p&gt;Je to
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Zprovoznění linuxptp na Raspberry Pi</title>
    <link href="http://errquille.github.io/2017/03/13/Zprovozneni-linuxptp-na-Raspberry-Pi/"/>
    <id>http://errquille.github.io/2017/03/13/Zprovozneni-linuxptp-na-Raspberry-Pi/</id>
    <published>2017-03-13T15:36:52.000Z</published>
    <updated>2017-03-20T14:49:14.378Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --><h2 id="Overeni-podpory-pro-linuxptp"><a href="#Overeni-podpory-pro-linuxptp" class="headerlink" title="Ověření podpory pro linuxptp"></a>Ověření podpory pro linuxptp</h2><p>K zjištění, zda můžeme využít linuxptp, je nejprve zapotřebí zjistit, zda náš síťový adaptér podporuje timestamping.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ethtool -T wlan0</div><div class="line">Time stamping parameters for wlan0:</div><div class="line">Capabilities:</div><div class="line">  software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)</div><div class="line">  software-system-clock (SOF_TIMESTAMPING_SOFTWARE)</div><div class="line">PTP Hardware Clock: none</div><div class="line">Hardware Transmit Timestamp Modes: none</div><div class="line">Hardware Receive Filter Modes: none</div></pre></td></tr></table></figure><p></p><p>V základu podporuje naše Raspberry pouze přijímání značek v softwaru. To je totiž naimplementováno v hlavním síťovém kódu. Odesílání značek musí být implemetnováno ovladačem síťové karty. Přesnější hardware timestamping pak využívá hardwaru s podporou PTP a vlastními hodinami. To WiFi USB modul <a href="https://thepihut.com/products/raspberry-pi-wipi-wireless-adapter" target="_blank" rel="external">WiPi</a> ani integrovaný čip v novém Raspberry Pi 3, které používáme, nemá. Příkaz lshw -C network nám poví o adaptéru wlan sítě a použitém ovladači.</p><figure class="highlight bash"><figcaption><span>Raspberry s integrovaným čipem</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ sudo lshw -C network</div><div class="line">*-network:0</div><div class="line">  description: Wireless interface</div><div class="line">  physical id: 2</div><div class="line">  logical name: wlan0</div><div class="line">  serial: b8:27:eb:8d:d5:ff</div><div class="line">  capabilities: ethernet physical wireless</div><div class="line">  configuration: broadcast=yes driver=brcmfmac driverversion=7.45.41.26 firmware=01-df77e4a7 ip= multicast=yes wireless=IEEE 802.11bgn</div></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>Raspberry s USB WiFi modulem</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ lshw -C network</div><div class="line">*-usb</div><div class="line">  description: Wireless interface</div><div class="line">  product: 802.11 n WLAN</div><div class="line">  vendor: Ralink</div><div class="line">  physical id: 1</div><div class="line">  bus info: usb@1:1</div><div class="line">  logical name: wlan0</div><div class="line">  version: 1.01</div><div class="line">  serial: 1.0</div><div class="line">  capabilities: usb-2.00 ethernet physical wireless</div><div class="line">  configuration: broadcast=yes driver=rt2800usb driverversion=4.4.38+ firmware=0.29 ip= link=yes maxpower=450mA multicast=yes speed=480Mbit/s wireless=IEEE 802.11bgn</div></pre></td></tr></table></figure><h2 id="Oprava-ovladace-brcmfmac"><a href="#Oprava-ovladace-brcmfmac" class="headerlink" title="Oprava ovladače brcmfmac"></a>Oprava ovladače brcmfmac</h2><p>Raspbian tedy pro integrovaný modul využívá ovladač brcmfmac, který nepodporuje software timestamping. Ve veřejných emailech <a href="https://sourceforge.net/p/linuxptp/mailman/message/35565972/" target="_blank" rel="external">#1</a> a <a href="https://sourceforge.net/p/linuxptp/mailman/message/35474590/" target="_blank" rel="external">#2</a> jsem našel řešení. Obě navrhované úpravy provedeme v zdrojovém souboru ovladače core.c. První krok je tedy sehnat zdrojový kód pro Raspbian.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir raspbian</div><div class="line">$ <span class="built_in">cd</span> raspbian</div><div class="line">$ git <span class="built_in">clone</span> --depth=1 git://github.com/raspberrypi/linux.git</div></pre></td></tr></table></figure><p></p><p>Dále upravíme soubor linux/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c.</p><figure class="highlight diff"><figcaption><span>linux/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@@ -236,6 +236,9 @@ static netdev_tx_t brcmf_netdev_start_xmit(struct sk_buff *skb,</div><div class="line"> goto done;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="addition">+  /* Transmit timestamping  */</span></div><div class="line"><span class="addition">+  skb_tx_timestamp(skb);</span></div><div class="line"><span class="addition">+</span></div><div class="line"> if (eh-&gt;h_proto == htons(ETH_P_PAE))</div><div class="line"> atomic_inc(&amp;ifp-&gt;pend_8021x_cnt);</div><div class="line"></div><div class="line">@@ -432,6 +435,7 @@ static void brcmf_ethtool_get_drvinfo(struct net_device *ndev,</div><div class="line"></div><div class="line"> static const struct ethtool_ops brcmf_ethtool_ops = &#123;</div><div class="line"> .get_drvinfo = brcmf_ethtool_get_drvinfo,</div><div class="line"><span class="addition">+  .get_ts_info    = ethtool_op_get_ts_info</span></div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> static int brcmf_netdev_stop(struct net_device *ndev)</div></pre></td></tr></table></figure><p>Tím by měl ovladač být připraven.</p><h2 id="Oprava-ovladace-rt2800usb"><a href="#Oprava-ovladace-rt2800usb" class="headerlink" title="Oprava ovladače rt2800usb"></a>Oprava ovladače rt2800usb</h2><p>Pro ovladač usb modulu použijeme stejné úpravy jako předtím, pouze jinde.<br></p><figure class="highlight diff"><figcaption><span>linux/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@@ -148,6 +148,8 @@ void rt2x00mac_tx(struct ieee80211_hw *hw,</div><div class="line"> if (rt2x00mac_tx_rts_cts(rt2x00dev, queue, skb))</div><div class="line"> goto exit_fail;</div><div class="line"> &#125;</div><div class="line"><span class="addition">+  /* Transmit timestamping */</span></div><div class="line"><span class="addition">+  skb_tx_timestamp(skb);</span></div><div class="line"></div><div class="line"> if (unlikely(rt2x00queue_write_tx_frame(queue, skb, control-&gt;sta, false)))</div><div class="line"> goto exit_fail;</div><div class="line">@@ -839,3 +841,8 @@ bool rt2x00mac_tx_frames_pending(struct ieee80211_hw *hw)</div><div class="line"> return false;</div><div class="line"> &#125;</div><div class="line"> EXPORT_SYMBOL_GPL(rt2x00mac_tx_frames_pending);</div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+static const struct ethtool_ops brcmf_ethtool_ops = &#123;</span></div><div class="line"><span class="addition">+  .get_ts_info    = ethtool_op_get_ts_info</span></div><div class="line"><span class="addition">+&#125;;</span></div><div class="line"><span class="addition">+</span></div></pre></td></tr></table></figure><p></p><h2 id="Kompilace-kernelu"><a href="#Kompilace-kernelu" class="headerlink" title="Kompilace kernelu"></a>Kompilace kernelu</h2><p>Linuxptp vyžaduje, aby v kernelu bylo povoleno několik možností. Kompletní postup kompilace je <a href="https://www.raspberrypi.org/documentation/linux/kernel/building.md" target="_blank" rel="external">zde</a>. Pouze .config použijeme defaultní z arch/arm/configs/bcmrpi_defconfig a upravíme jej pomocí menuconfig. Potřebné jsou možnosti PPS, NETWORK_PHY_TIMESTAMPING a PTP_1588_CLOCK. Zde můžeme povypínat a pozapínat i jiné možnosti. Já například přepnul Přeemption Model na Preemptible Kernel. To by mělo vést k nižší latenci bez ztráty výkonu. Následuje sada příkazů, které v mém případě udělaly to potřebné pro Compute Module. Kompiluju na jiném PC a filesystem jsem měl mountovaný do /mnt/, sdb2- je root složka a /boot/ je /boot/.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/raspberrypi/linux slotcar-kernel</div><div class="line">git <span class="built_in">clone</span> https://github.com/raspberrypi/tools</div><div class="line"></div><div class="line">CCPREFIX=$(<span class="built_in">pwd</span>)/tools/arm-bcm2708-arm-bcm2708hardfp-linux-gnueabi/bin/bcm2708hardfp-</div><div class="line"><span class="built_in">cd</span> slotcar-kernel</div><div class="line">KERNEL_SRC=$(<span class="built_in">pwd</span>)</div><div class="line">KERNEL=kernel</div><div class="line"></div><div class="line">cp arch/arm/configs/bcmrpi_defconfig .config</div><div class="line"></div><div class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CCPREFIX&#125;</span> menuconfig</div><div class="line">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;CCPREFIX&#125;</span> zImage modules dtbs -j5</div><div class="line"></div><div class="line">sudo scripts/mkknlimg arch/arm/boot/zImage /mnt/boot/kernel.img</div><div class="line">sudo cp arch/arm/boot/dts/*.dtb /mnt/boot/</div><div class="line">sudo cp arch/arm/boot/dts/overlays/*.dtb* /mnt/boot/overlays/</div><div class="line">sudo cp arch/arm/boot/dts/overlays/README /mnt/boot/overlays/</div><div class="line"></div><div class="line">sudo make ARCH=arm CROSS_COMPILE=&#123;CCPREFIX&#125; INSTALL_MOD_PATH=/mnt/sdb2-usdb-RPi-MSD-_0001_00/ modules_install</div><div class="line">sudo make ARCH=arm CROSS_COMPILE=&#123;CCPREFIX&#125; INSTALL_HDR_PATH=/mnt/sdb2-usdb-RPi-MSD-_0001_00/usr/src headers_install</div></pre></td></tr></table></figure><p></p><h3 id="Zakazani-upgradu-kernelu"><a href="#Zakazani-upgradu-kernelu" class="headerlink" title="Zakázání upgradu kernelu"></a>Zakázání upgradu kernelu</h3><p>V systému občas provede aktualizaci balíčků, některé z nich pracují s kernelem a naše úpravy by aktualizace zrušila.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">$ dpkg -S /boot/*</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2708-rpi-0-w.dtb</div><div class="line">raspberrypi-kernel: /boot/bcm2708-rpi-b.dtb</div><div class="line">raspberrypi-kernel: /boot/bcm2708-rpi-b-plus.dtb</div><div class="line">raspberrypi-kernel: /boot/bcm2708-rpi-cm.dtb</div><div class="line">raspberrypi-kernel: /boot/bcm2709-rpi-2-b.dtb</div><div class="line">raspberrypi-kernel: /boot/bcm2710-rpi-3-b.dtb</div><div class="line">raspberrypi-kernel: /boot/bcm2710-rpi-cm3.dtb</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2835-rpi-a.dtb</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2835-rpi<span class="_">-a</span>-plus.dtb</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2835-rpi-b.dtb</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2835-rpi-b-plus.dtb</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2835-rpi-b-rev2.dtb</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2835-rpi-zero.dtb</div><div class="line">dpkg-query: no path found matching pattern /boot/bcm2836-rpi-2-b.dtb</div><div class="line">raspberrypi-bootloader: /boot/bootcode.bin</div><div class="line">dpkg-query: no path found matching pattern /boot/cmdline.txt</div><div class="line">dpkg-query: no path found matching pattern /boot/config.txt</div><div class="line">raspberrypi-kernel: /boot/COPYING.linux</div><div class="line">raspberrypi-bootloader: /boot/fixup_cd.dat</div><div class="line">raspberrypi-bootloader: /boot/fixup.dat</div><div class="line">raspberrypi-bootloader: /boot/fixup_db.dat</div><div class="line">raspberrypi-bootloader: /boot/fixup_x.dat</div><div class="line">dpkg-query: no path found matching pattern /boot/issue.txt</div><div class="line">raspberrypi-kernel: /boot/kernel7.img</div><div class="line">raspberrypi-kernel: /boot/kernel.img</div><div class="line">raspberrypi-bootloader: /boot/LICENCE.broadcom</div><div class="line">dpkg-query: no path found matching pattern /boot/LICENSE.oracle</div><div class="line">dpkg-query: no path found matching pattern /boot/os_config.json</div><div class="line">raspberrypi-kernel: /boot/overlays</div><div class="line">raspberrypi-bootloader: /boot/start_cd.elf</div><div class="line">raspberrypi-bootloader: /boot/start_db.elf</div><div class="line">raspberrypi-bootloader: /boot/start.elf</div><div class="line">raspberrypi-bootloader: /boot/start_x.elf</div></pre></td></tr></table></figure><p></p><p>Zde tedy vydíme, že kernel je udržován balíčkem raspberrypi-kernel. Vyřadíme jej z apt spolu s raspberrypi-bootloader.<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-mark hold raspberrypi-kernel raspberrypi-bootloader</div></pre></td></tr></table></figure><p></p><h2 id="linuxptp"><a href="#linuxptp" class="headerlink" title="linuxptp"></a>linuxptp</h2><h3 id="Instalace"><a href="#Instalace" class="headerlink" title="Instalace"></a>Instalace</h3><p>Linuxptp kompiluji přímo v Raspberry. Stačí stáhnout zdrojové soubory a zavolat make a make install.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --&gt;&lt;h2 id=&quot;Overeni-podpory-pro-linuxptp&quot;&gt;&lt;a href=&quot;#Overeni-podpory-pro-linuxptp&quot;
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Čas a Raspberry Pi</title>
    <link href="http://errquille.github.io/2017/03/11/Cas-a-Raspberry-Pi/"/>
    <id>http://errquille.github.io/2017/03/11/Cas-a-Raspberry-Pi/</id>
    <published>2017-03-11T18:25:35.000Z</published>
    <updated>2017-03-24T03:06:04.231Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --><h2 id="Terminologie"><a href="#Terminologie" class="headerlink" title="Terminologie"></a>Terminologie</h2><p>V anglických textech se při popisu počítačových hodin objevují slova accuracy a resolution. Resolution, česky rozlišení, udává nejmenší díl, jehož změnu jsme schopni rozlišit. Accuracy, česky přesnost, je rozdíl změřeného času oproti skutečnému času, tedy míra chyby. Skutečný čas je ale záležitost, kterou nikdy neměříme naprosto přesně, a tak nám k určení přesnosti stačí porovnání s hodinami, které jsou prokázány jako dostatečně dobré. Od přesnosti se také rozlišuje preciznost (precision). <img src="/img/accuracy-vs-precision.jpeg"> Rozdíl mezi nimi je, že preciznost udává míru statistické chyby, přesnost udává systematickou chybu.</p><h2 id="STC"><a href="#STC" class="headerlink" title="STC"></a>STC</h2><p>Raspberry Pi nemá RTC obvod, TSC ani HPET. Jako zdroj hodin používá vlastní softwareový čítač STC.<br></p><figure class="highlight c"><figcaption><span>STC v kernelu Raspberry</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* The STC is a free running counter that increments at the rate of 1MHz */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STC_FREQ_HZ 1000000</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Constants generated by clocks_calc_mult_shift(m, s, 1MHz, NSEC_PER_SEC, 60).</div><div class="line"> * This gives a resolution of about 1us and a wrap period of about 1h11min.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_MULT4194304000u</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SC_SHIFT22</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> cycle_t <span class="title">stc_read_cycles</span><span class="params">(<span class="keyword">struct</span> clocksource *cs)</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">/* STC: a free running counter that increments at the rate of 1MHz */</span></div><div class="line"><span class="keyword">return</span> (<span class="keyword">cycle_t</span>) readl(__io_address(ST_BASE + <span class="number">0x04</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> clocksource clocksource_stc = &#123;</div><div class="line">.name = <span class="string">"stc"</span>,</div><div class="line">.rating = <span class="number">300</span>,</div><div class="line">.read = stc_read_cycles,</div><div class="line">.mask = CLOCKSOURCE_MASK(<span class="number">32</span>),</div><div class="line">.flags = CLOCK_SOURCE_IS_CONTINUOUS,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br>Tento čítač inkrementuje s frekvencí 1 MHz a má tedy rozlišení jedné mikrosekundy. Bez hardwareových hodin nemá z čeho být inicializován, a záleží tedy na synchronizaci k nastavení správného času a udržení vysoké přesnosti.<p></p><h2 id="PTP"><a href="#PTP" class="headerlink" title="PTP"></a>PTP</h2><p>PTP, precision time protocol, také známý jako IEEE 1588, je protokol k synchronizaci času mezi master zařízením a slave zařízením, podobně jako NTP. NTP je určeno k synchronizaci po internetu, a v lokální síti nedosahuje té nejvyšší přesnosti. To dalo prostor vzniku PTP, které si bere za cíl dosahovat vyšší přesnosti v lokálních sítích, potřebné pro řídící systémy, měřící systémy a systémy distribuce energie. Často bývá uváděná přesnost po synchronizaci pod jednu mikrosekundu. Pro systém Linux existují implementace PTP protokolu <a href="http://linuxptp.sourceforge.net/" target="_blank" rel="external">linuxptp</a> a <a href="https://github.com/ptpd/ptpd" target="_blank" rel="external">ptpd</a>.</p><h2 id="PPS"><a href="#PPS" class="headerlink" title="PPS"></a>PPS</h2><p>K porovnání a ověření, jaké přesnosti dosáhne synchronizace pomocí PTP, vyvedeme na jeden z výstupních pinů GPIO PPS signál. Poté na oscilátoru zjistíme, jaký posun mají mezi sebou hrany master a slave zařízení.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --&gt;&lt;h2 id=&quot;Terminologie&quot;&gt;&lt;a href=&quot;#Terminologie&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Měření dopravního zpoždění</title>
    <link href="http://errquille.github.io/2017/03/01/Mereni-dopravniho-zpozdeni/"/>
    <id>http://errquille.github.io/2017/03/01/Mereni-dopravniho-zpozdeni/</id>
    <published>2017-03-01T13:09:49.000Z</published>
    <updated>2017-03-13T19:09:30.786Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --><p>V minulém semestru jsem se zabýval synchronizací času a měřením dopravního zpoždění. Napsal jsem k tomu <a href="/pdf/indprojekt-wernisch.pdf">zprávu</a>. Na programu aut se však pár věcí změnilo, a tak zpoždění budu měřit znova, jestli nebudou jiná.</p><h2 id="Projekt-Slotcar-platooning"><a href="#Projekt-Slotcar-platooning" class="headerlink" title="Projekt Slotcar platooning"></a>Projekt Slotcar platooning</h2><p>Abych ale také představil, s čím pracuji.</p><div class="video-container"><iframe src="//www.youtube.com/embed/FD_QqYuvv_g" frameborder="0" allowfullscreen></iframe></div>Tým na Katedře řídící techniky vedený panem Ing. Zdeňkem Hurákem vytvořil model autodráhy a autíček. Jde o modifikovaná dráhová autíčka Carrera, do kterých se vměstnal modul Raspberry Pi, STM32 procesor, dálkové senzory a WiFi přijímač. Na Raspberry běží program, který řídí chod aut a zajišťuje i síťovou komunikaci mezi autíčky a PC s grafickým rozhraním.<br><img src="https://cyber.felk.cvut.cz/theses/pictures/487.jpg"><p></p><h2 id="Mereni-dopravniho-zpozdeni"><a href="#Mereni-dopravniho-zpozdeni" class="headerlink" title="Měření dopravního zpoždění"></a>Měření dopravního zpoždění</h2><p>V programu jsou do paketů implementovány časové značky. Porovnáním s časem při zpracovávání měříme dopravní zpoždění. Ta si pak ukládám do souboru a vlastní funkcí MATLABu převádím na histogramy.<br></p><figure class="highlight matlab"><figcaption><span>createfigure.m</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createfigure</span> <span class="params">(data1)</span></span></div><div class="line"><span class="comment">%  DATA1:  histogram data</span></div><div class="line">figure1 = figure;</div><div class="line"><span class="comment">% Create axes</span></div><div class="line">axes1 = axes(<span class="string">'Parent'</span>,figure1);</div><div class="line"><span class="comment">% Create histogram</span></div><div class="line">histogram(data1,<span class="string">'Parent'</span>,axes1,...</div><div class="line">    <span class="string">'BinMethod'</span>,<span class="string">'auto'</span>, <span class="string">'BinWidth'</span>,<span class="number">5</span>);</div><div class="line"><span class="comment">% Create xlabel</span></div><div class="line">xlabel(<span class="string">'ms'</span>);</div><div class="line"><span class="comment">% Create ylabel</span></div><div class="line">ylabel(<span class="string">'četnost'</span>);</div><div class="line"><span class="comment">% Create title</span></div><div class="line">title(&#123;<span class="string">'Dopravní zpoždění dvou aut'</span>&#125;,<span class="string">'FontSize'</span>,...</div><div class="line">      <span class="number">10</span>, <span class="string">'FontWeight'</span>, <span class="string">'normal'</span>);</div><div class="line">box(axes1,<span class="string">'on'</span>);</div><div class="line">grid(axes1,<span class="string">'on'</span>);</div><div class="line"><span class="comment">% Set the remaining axes properties</span></div><div class="line">set(axes1,<span class="string">'GridAlpha'</span>,<span class="number">1</span>,<span class="string">'MinorGridAlpha'</span>,<span class="number">1</span>,...</div><div class="line">    <span class="string">'XMinorTick'</span>,<span class="string">'on'</span>,...</div><div class="line">    <span class="string">'YMinorTick'</span>, <span class="string">'on'</span>,<span class="string">'YScale'</span>,<span class="string">'log'</span>);</div></pre></td></tr></table></figure><p></p><p>Takto jsem si kdysi změřil následující zpoždění. <img src="/img/dopravni-zpozdeni-1.png" title="Histogram dopravního zpoždění"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Tue Oct 03 2017 15:19:57 GMT+0200 (CEST) --&gt;&lt;p&gt;V minulém semestru jsem se zabýval synchronizací času a měřením dopravního
        
      
    
    </summary>
    
    
  </entry>
  
</feed>
